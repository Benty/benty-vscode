import fs from 'node:fs';
import path from 'node:path';
import process from 'node:process';
import chalk from 'chalk';
import { dedent } from 'ts-dedent';
const formatMessage = (message) => dedent(message.replace(/\t/g, '    '));
export const styles = {
    item: (message) => `    ${chalk.dim('-')} ${chalk.magenta(message)}`,
    string: (message) => chalk.yellow(`"${message}"`),
    url: (message) => chalk.magenta(message),
};
export const log = {
    list(title, items) {
        console.log(title);
        for (const item of items) {
            console.log(styles.item(item));
        }
        console.log();
    },
    warn(message) {
        console.log(chalk(chalk.yellow.inverse(' Warn '), '%s\n'), formatMessage(message));
    },
    error(message) {
        console.log(chalk(chalk.red.inverse(' Error '), '%s\n'), formatMessage(message));
    },
};
export const toRelativePath = (to) => path.join(process.cwd(), to);
export const readToString = (file) => {
    try {
        return fs.readFileSync(toRelativePath(file), 'utf8');
    }
    catch (error) {
        log.error(`Unable to read file, ${toRelativePath(file)}`);
        throw new Error(error);
    }
};
export const readToJson = (file) => {
    try {
        const contents = fs
            .readFileSync(toRelativePath(file), 'utf8')
            .replace(/\\"|"(?:\\"|[^"])*"|(\/\/.*|\/\*[\s\S]*?\*\/)/g, (m, g) => g ? '' : m);
        return JSON.parse(contents);
    }
    catch (error) {
        log.error(`Unable to read file, ${toRelativePath(file)}`);
        throw new Error(error);
    }
};
export const writeToFile = (where, what) => {
    try {
        fs.writeFileSync(where, what, 'utf8');
    }
    catch (error) {
        log.error(`Unable to write file, ${where}`);
        throw new Error(error);
    }
};
export const makeDirectory = (where) => {
    try {
        fs.mkdirSync(path.dirname(where), { recursive: true });
    }
    catch (error) {
        log.error(`Unable to make directory, ${path.dirname(where)}`);
        throw new Error(error);
    }
};
export const importFresh = async (modulePath) => {
    const freshModulePath = `${modulePath}?update=${Date.now()}`;
    try {
        const freshModule = (await import(freshModulePath));
        return freshModule.default;
    }
    catch {
        return undefined;
    }
};
